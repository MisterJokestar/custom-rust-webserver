# Feature: Add `Date` Response Header with RFC 7231 Format

## Overview

HTTP/1.1 requires all responses to include a `Date` header field as per [RFC 7231 Section 7.1.1.2](https://tools.ietf.org/html/rfc7231#section-7.1.1.2). The header must contain a timestamp in IMF-fixdate format (e.g., `Date: Wed, 10 Feb 2026 14:30:45 GMT`).

Currently, rcomm does not automatically add this header, making responses non-compliant with HTTP/1.1 specifications. This feature ensures every response from the server includes a properly formatted `Date` header.

### Importance
- **HTTP/1.1 Compliance**: RFC 7231 mandates the Date header for all HTTP responses
- **Client Expectations**: HTTP clients often rely on server-sent Date headers for cache validation and other protocol logic
- **No External Dependencies**: Implementation uses only Rust standard library (`std::time::SystemTime`)

### Scope
- Automatically add a `Date` header to all HTTP responses generated by the server
- Manual date formatting without external dependencies (no chrono, time crate, etc.)
- Format must strictly comply with RFC 7231 IMF-fixdate: `Ddd, DD Mmm YYYY HH:MM:SS GMT`

---

## Files to Modify or Create

### Files to Modify
1. **`src/models/http_response.rs`**
   - Add a utility function to format timestamps in RFC 7231 format
   - Modify `HttpResponse::build()` to automatically insert the Date header

2. **`src/main.rs`**
   - No changes needed (Date header is added at the HttpResponse level, not at the handler level)

### Files to Create
None. All logic fits within the existing `http_response.rs` module.

---

## Step-by-Step Implementation Details

### Step 1: Add RFC 7231 Date Formatting Function

Create a private utility function in `src/models/http_response.rs` to convert a `SystemTime` to an RFC 7231-compliant string.

**Function Signature:**
```rust
fn format_http_date(time: std::time::SystemTime) -> String
```

**Implementation Notes:**
- Use `SystemTime::UNIX_EPOCH` as reference point
- Calculate elapsed time since Unix epoch in seconds
- Convert Unix timestamp to calendar date and time (UTC)
- Use lookup tables or manual calculation for day-of-week and month names
- Return string in format: `Ddd, DD Mmm YYYY HH:MM:SS GMT`

**Pseudocode:**
```
fn format_http_date(time: SystemTime) -> String:
    duration = time.duration_since(UNIX_EPOCH)
    total_seconds = duration.as_secs()

    // Calculate days since epoch and time within day
    days_since_epoch = total_seconds / 86400
    secs_in_day = total_seconds % 86400

    hours = secs_in_day / 3600
    minutes = (secs_in_day % 3600) / 60
    seconds = secs_in_day % 60

    // Calculate year, month, day from days_since_epoch
    year, month, day = calculate_ymd_from_days(days_since_epoch)

    // Calculate day of week
    day_of_week = calculate_day_of_week(days_since_epoch)

    // Format as "Ddd, DD Mmm YYYY HH:MM:SS GMT"
    return format_string(day_of_week, day, month, year, hours, minutes, seconds)
```

**Implementation Strategy:**
- Use pre-computed arrays for month names, day names
- Handle leap years correctly (Gregorian calendar)
- Use Zeller's congruence or similar algorithm for day-of-week calculation
- All calculations must be deterministic and timezone-aware (UTC only)

### Step 2: Create Date-Formatting Utility with Leap Year Handling

The core challenge is converting Unix timestamp to calendar date without external dependencies. Here's the approach:

**Constants to define:**
```rust
const SECONDS_PER_DAY: u64 = 86400;
const DAYS_PER_YEAR: u64 = 365;
const DAYS_PER_LEAP_YEAR: u64 = 366;

const MONTH_NAMES: &[&str] = &["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const DAY_NAMES: &[&str] = &["Thu", "Fri", "Sat", "Sun", "Mon", "Tue", "Wed"];

// Days in each month (non-leap year)
const DAYS_IN_MONTH: &[u32] = &[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
```

**Helper functions:**
```rust
fn is_leap_year(year: u32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

fn days_in_year(year: u32) -> u32 {
    if is_leap_year(year) { 366 } else { 365 }
}

fn days_in_feb(year: u32) -> u32 {
    if is_leap_year(year) { 29 } else { 28 }
}

fn day_of_week_from_timestamp(unix_seconds: u64) -> usize {
    // Jan 1, 1970 was Thursday (index 0)
    let days = unix_seconds / SECONDS_PER_DAY;
    (days as usize + 4) % 7  // +4 because Unix epoch was Thursday
}

fn ymd_from_unix_seconds(unix_seconds: u64) -> (u32, u32, u32) {
    // Returns (year, month: 1-12, day: 1-31)
    let mut days = (unix_seconds / SECONDS_PER_DAY) as u32;
    let mut year = 1970;

    // Move forward year by year
    loop {
        let days_this_year = days_in_year(year);
        if days < days_this_year {
            break;
        }
        days -= days_this_year;
        year += 1;
    }

    // Find month and day
    let mut month = 1;
    let mut day = days + 1; // days are 0-indexed

    for m in 1..=12 {
        let days_in_m = if m == 2 {
            days_in_feb(year)
        } else {
            DAYS_IN_MONTH[m as usize - 1]
        };

        if day <= days_in_m as u32 {
            month = m;
            break;
        }
        day -= days_in_m as u32;
    }

    (year, month, day)
}
```

### Step 3: Modify `HttpResponse::build()`

Update the `build()` method to automatically add the Date header:

```rust
impl HttpResponse {
    pub fn build(version: String, code: u16) -> HttpResponse {
        let headers = HashMap::<String, String>::new();
        let phrase = get_status_phrase(code);
        let mut response = HttpResponse {
            version,
            status_code: code,
            status_phrase: phrase,
            headers,
            body: None,
        };

        // Add Date header automatically
        let date_header = format_http_date(std::time::SystemTime::now());
        response.add_header("Date".to_string(), date_header);

        response
    }
}
```

### Step 4: Add Tests for Date Header

Add comprehensive unit tests to verify RFC 7231 compliance:

```rust
#[test]
fn build_adds_date_header_automatically() {
    let resp = HttpResponse::build("HTTP/1.1".to_string(), 200);
    let date = resp.try_get_header("Date".to_string());
    assert!(date.is_some());
    assert!(date.unwrap().len() > 0);
}

#[test]
fn date_header_has_correct_format() {
    let resp = HttpResponse::build("HTTP/1.1".to_string(), 200);
    let date = resp.try_get_header("Date".to_string()).unwrap();
    // Format: "Ddd, DD Mmm YYYY HH:MM:SS GMT"
    // Example: "Wed, 10 Feb 2026 14:30:45 GMT"
    assert_eq!(date.len(), 29); // Fixed length for RFC 7231 format
    assert!(date.ends_with(" GMT"));

    // Validate day names (first 3 chars)
    let day_part = &date[0..3];
    assert!(["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        .contains(&day_part));

    // Validate month names
    assert!(date.contains("Jan") || date.contains("Feb") ||
            date.contains("Mar") || date.contains("Apr") ||
            date.contains("May") || date.contains("Jun") ||
            date.contains("Jul") || date.contains("Aug") ||
            date.contains("Sep") || date.contains("Oct") ||
            date.contains("Nov") || date.contains("Dec"));
}

#[test]
fn date_header_in_http_response_output() {
    let resp = HttpResponse::build("HTTP/1.1".to_string(), 200);
    let output = format!("{resp}");
    assert!(output.contains("date: "));
    assert!(output.contains("GMT"));
}

#[test]
fn all_status_codes_include_date_header() {
    for status_code in &[200, 201, 301, 304, 400, 404, 500, 503] {
        let resp = HttpResponse::build("HTTP/1.1".to_string(), *status_code);
        let date = resp.try_get_header("Date".to_string());
        assert!(date.is_some(), "Status {} missing Date header", status_code);
    }
}

#[test]
fn format_http_date_is_consistent_within_second() {
    // Multiple calls within the same second should produce similar dates
    let resp1 = HttpResponse::build("HTTP/1.1".to_string(), 200);
    let resp2 = HttpResponse::build("HTTP/1.1".to_string(), 200);

    let date1 = resp1.try_get_header("Date".to_string()).unwrap();
    let date2 = resp2.try_get_header("Date".to_string()).unwrap();

    // Allow for up to 1 second difference
    assert_eq!(date1.len(), date2.len());
    assert_eq!(date1[0..24], date2[0..24]); // Same except possibly last second
}
```

### Step 5: Integration Testing

The existing integration test in `src/bin/integration_test.rs` should automatically verify Date header presence. Add a new test case:

```rust
fn test_date_header_present_in_response() -> TestResult {
    let response = send_request("/");

    if response.contains("date: ") {
        TestResult::Pass("Date header found in 200 response".to_string())
    } else {
        TestResult::Fail("Date header missing from response".to_string())
    }
}

fn test_date_header_format_valid() -> TestResult {
    let response = send_request("/");

    // Extract date line
    if let Some(date_line) = response.lines()
        .find(|line| line.starts_with("date: ")) {

        let date_value = &date_line[6..]; // Skip "date: "

        // Validate format: "Ddd, DD Mmm YYYY HH:MM:SS GMT"
        if date_value.len() == 29 && date_value.ends_with("GMT") {
            TestResult::Pass("Date header format valid".to_string())
        } else {
            TestResult::Fail(format!("Invalid date format: {}", date_value))
        }
    } else {
        TestResult::Fail("Date header not found".to_string())
    }
}
```

---

## Code Snippets and Pseudocode

### Complete function signature for `format_http_date()`

```rust
use std::time::{SystemTime, UNIX_EPOCH};

fn format_http_date(time: SystemTime) -> String {
    const SECONDS_PER_DAY: u64 = 86400;
    const MONTH_NAMES: &[&str] = &["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const DAY_NAMES: &[&str] = &["Thu", "Fri", "Sat", "Sun", "Mon", "Tue", "Wed"];

    let duration = time.duration_since(UNIX_EPOCH).unwrap_or_default();
    let total_seconds = duration.as_secs();

    // Calculate time components
    let secs_in_day = total_seconds % SECONDS_PER_DAY;
    let hours = secs_in_day / 3600;
    let minutes = (secs_in_day % 3600) / 60;
    let seconds = secs_in_day % 60;

    // Calculate day of week (Unix epoch was Thursday)
    let days_since_epoch = total_seconds / SECONDS_PER_DAY;
    let day_of_week = (days_since_epoch as usize + 4) % 7;

    // Calculate year, month, day
    let (year, month, day) = calculate_ymd(total_seconds);

    // Format: "Ddd, DD Mmm YYYY HH:MM:SS GMT"
    format!(
        "{}, {:02} {} {} {:02}:{:02}:{:02} GMT",
        DAY_NAMES[day_of_week],
        day,
        MONTH_NAMES[(month - 1) as usize],
        year,
        hours,
        minutes,
        seconds
    )
}
```

### Full calendar calculation helper

```rust
fn is_leap_year(year: u32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

fn calculate_ymd(unix_seconds: u64) -> (u32, u32, u32) {
    const DAYS_PER_YEAR: u32 = 365;
    const SECONDS_PER_DAY: u64 = 86400;
    const DAYS_IN_MONTH: &[u32] = &[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    let mut days = (unix_seconds / SECONDS_PER_DAY) as u32;
    let mut year = 1970;

    // Advance year by year
    loop {
        let days_this_year = if is_leap_year(year) { 366 } else { 365 };
        if days < days_this_year {
            break;
        }
        days -= days_this_year;
        year += 1;
    }

    // Advance month by month
    let mut month = 1;
    for m in 0..12 {
        let days_in_m = if m == 1 && is_leap_year(year) {
            29
        } else {
            DAYS_IN_MONTH[m]
        };

        if days < days_in_m {
            month = m as u32 + 1;
            break;
        }
        days -= days_in_m;
    }

    let day = days + 1; // Convert from 0-indexed to 1-indexed

    (year, month, day)
}
```

---

## Testing Strategy

### Unit Tests (in `src/models/http_response.rs`)

1. **Header Presence Test**: Verify Date header is automatically added
2. **Format Validation Test**: Ensure RFC 7231 compliance (length, GMT suffix, weekday/month names)
3. **Multiple Status Codes Test**: Confirm Date header is added for all status codes (200, 404, 500, etc.)
4. **Consistency Test**: Verify the same timestamp is used within a second
5. **Edge Cases**:
   - Responses with and without bodies
   - Leap years (Feb 29)
   - Chained builder calls
   - Header case-insensitivity (header stored as "date", retrieved as "Date")

### Integration Tests (in `src/bin/integration_test.rs`)

1. **Response Includes Date**: Send HTTP request and verify Date header is in response
2. **Date Format Compliance**: Parse returned Date header and validate format
3. **All Routes Include Date**: Test multiple routes (/, /index.html, 404, etc.) all have Date
4. **Static Content Consistency**: Multiple requests to same resource get consistent Date headers (within expected time range)

### Manual Testing

```bash
# Build and run server
cargo build
cargo run &

# Test with curl (check for date header)
curl -v http://127.0.0.1:7878/
# Look for: "date: Wed, 10 Feb 2026 14:30:45 GMT"

# Test with nc (raw TCP)
echo -e "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n" | nc localhost 7878
# Verify date header is present and formatted correctly
```

---

## Edge Cases and Considerations

### Edge Case 1: Leap Year Handling
- **Issue**: Feb 29 exists only in leap years
- **Solution**: `is_leap_year()` function correctly identifies leap years (divisible by 4, except centuries not divisible by 400)
- **Test**: Add test for Feb 28/29 boundary, especially year 2000 (leap) and 1900 (not leap)

### Edge Case 2: Unix Timestamp Boundaries
- **Issue**: Very old or very future dates might cause overflow
- **Solution**: Use u64 throughout; overflow naturally wraps (not critical for HTTP use case)
- **Scope**: HTTP is unlikely to serve requests before 1970 or after year 292 billion

### Edge Case 3: SystemTime Errors
- **Issue**: `SystemTime::now()` could theoretically fail or return time before UNIX_EPOCH
- **Solution**: Use `.unwrap_or_default()` on `duration_since()` to fall back to epoch (1970-01-01)
- **Alternative**: Use system time library fallback or hardcoded default

### Edge Case 4: Case Insensitivity
- **Behavior**: HTTP headers are case-insensitive, but RFC 7231 recommends "Date" with capital D
- **Current Implementation**: `HttpResponse::add_header()` stores headers in lowercase
- **Display**: Headers are printed as lowercase (e.g., "date: Wed, 10 Feb 2026...")
- **Note**: This is acceptable; HTTP/1.1 clients treat "date:" and "Date:" identically

### Edge Case 5: Daylight Saving Time
- **Decision**: HTTP dates MUST always be in UTC (GMT), never in local time
- **Implementation**: All calculations use UNIX_EPOCH (UTC reference), no timezone conversion
- **Validation**: Test across system timezone changes (or document as UTC-only)

### Edge Case 6: Concurrent Response Generation
- **Issue**: Thread pool dispatches work to multiple workers; each may call `SystemTime::now()` independently
- **Behavior**: This is correctâ€”each response gets the current time when it's processed
- **Test**: Verify Date headers differ slightly between concurrent responses

### Edge Case 7: Response Caching
- **Consideration**: Date headers should NOT be cached along with responses
- **Scope**: Out of scope for this feature (caching not yet implemented)
- **Future**: When caching is added, ensure Date is regenerated per response

---

## Implementation Checklist

- [ ] Create `format_http_date()` function in `src/models/http_response.rs`
- [ ] Create helper functions: `is_leap_year()`, `calculate_ymd()`
- [ ] Modify `HttpResponse::build()` to call `add_header("Date", formatted_date)`
- [ ] Add constants for month/day names and days per month
- [ ] Write unit tests for date formatting
- [ ] Write unit tests for Date header presence in responses
- [ ] Write unit tests for format validation (RFC 7231)
- [ ] Write integration tests for Date header in HTTP responses
- [ ] Test with multiple status codes (2xx, 3xx, 4xx, 5xx)
- [ ] Test edge cases (leap years, day/month boundaries)
- [ ] Document RFC 7231 compliance in CLAUDE.md
- [ ] Run full test suite: `cargo test`
- [ ] Run integration tests: `cargo run --bin integration_test`
- [ ] Manual verification with curl/nc

---

## References

- [RFC 7231 - HTTP/1.1 Semantics and Content, Section 7.1.1.2](https://tools.ietf.org/html/rfc7231#section-7.1.1.2)
- [HTTP Date Format (IMF-fixdate)](https://tools.ietf.org/html/rfc7231#section-7.1.1.1)
- [Rust std::time::SystemTime](https://doc.rust-lang.org/std/time/struct.SystemTime.html)
- [Gregorian Calendar Calculations](https://en.wikipedia.org/wiki/Gregorian_calendar#Leap_year_rules)

---

## Estimated Effort

- **Implementation**: 1-2 hours (date formatting logic + tests)
- **Testing**: 1 hour (unit + integration tests)
- **Code Review**: 30 minutes
- **Total**: ~3 hours
- **Complexity**: 3/10 (calendar math is straightforward; main challenge is avoiding external dependencies)

---

## Success Criteria

1. All HTTP responses include a `Date` header
2. Date format strictly complies with RFC 7231 IMF-fixdate format
3. No external dependencies introduced (std library only)
4. All existing tests continue to pass
5. New unit tests achieve 100% coverage of date formatting logic
6. Integration tests verify Date header in responses
7. Edge cases (leap years, boundaries) are tested and handled
8. No performance regression in request handling

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**rcomm** is a multi-threaded HTTP web server written in Rust (edition 2024) from scratch with no external dependencies. It serves static HTML, CSS, and JavaScript files using a convention-based routing system derived from the `pages/` directory structure.

## Build & Run Commands

```bash
cargo build                            # Build all binaries (server + integration tests)
cargo run                              # Run the server (default 127.0.0.1:7878)
cargo test                             # Run all unit tests (34 tests across lib + models)
cargo test <test_name>                 # Run a single test by name
cargo test -- --nocapture              # Run tests with println! output visible
cargo run --bin integration_test       # Run end-to-end integration tests (10 tests)
```

The server port/address can be overridden via environment variables:

- `RCOMM_PORT` (default: `7878`)
- `RCOMM_ADDRESS` (default: `127.0.0.1`)

## Architecture

### Core Components

1. **Thread Pool** (`src/lib.rs`) — Custom thread pool using `mpsc` channels and `Arc<Mutex<Receiver>>` for work distribution. Default 4 workers, graceful shutdown via Drop trait.

2. **HTTP Models** (`src/models/`) — Hand-rolled HTTP request/response parsing and serialization:
   - `http_methods.rs` — HTTP verb enum (uppercase only: "GET" parses, "get" does not)
   - `http_request.rs` — Request struct with TCP stream parser (`build_from_stream()`)
   - `http_response.rs` — Response struct with auto Content-Length on `add_body()`
   - `http_status_codes.rs` — Status code to phrase mapping

3. **Main Server** (`src/main.rs`) — TCP listener loop dispatching connections to the thread pool. Contains `build_routes()` (recursive `pages/` scanner) and `handle_connection()`. Route targets are cleaned via `clean_route()` which strips empty segments, `.`, and `..`.

4. **Integration Tests** (`src/bin/integration_test/`) — Separate binary that spawns the real server on a random port, sends HTTP requests over TCP, and validates responses. Split into two modules:
   - `test_framework.rs` — Server lifecycle helpers (`pick_free_port`, `start_server`, `wait_for_server`), HTTP client (`send_request`, `read_response`), and mini test framework (`TestResult`, `run_test`, assert helpers)
   - `http_tests.rs` — The actual test functions and `run_http_tests()` entry point

### Request/Response Pattern

Both `HttpRequest` and `HttpResponse` use a builder pattern with methods returning `&mut Self`. `build()` returns an owned value, so chain after a `let mut` binding:

```rust
let mut response = HttpResponse::build(String::from("HTTP/1.1"), 200);
response.add_header("Content-Type".to_string(), "text/html".to_string());
response.add_body(content.into());
```

Headers are stored lowercase internally. `as_bytes()` serializes the full HTTP message (headers + body).

### Convention-Based Routing

Routes are auto-generated by recursively scanning `pages/` directory:

- `pages/index.html` → `/`
- `pages/howdy/page.html` → `/howdy`
- `pages/howdy/page.css` → `/howdy/page.css`
- `pages/not_found.html` → Used for 404 responses (not routed)

Pattern: Files named `index.html` or `page.html` become routes at their directory's path level. Other `.html`/`.css`/`.js` files are routed by their full relative path.

### Module Structure

The library crate (`src/lib.rs`) exports `ThreadPool` and the `models` module. Models are re-exported via `src/models.rs` (barrel file, not `mod.rs`). The server binary (`src/main.rs`) and integration test binary (`src/bin/integration_test/main.rs`) are discovered automatically by Cargo.

## Known Issues

- Extensive use of `.unwrap()` — no graceful error handling in routing/file serving
